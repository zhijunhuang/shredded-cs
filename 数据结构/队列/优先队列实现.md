## 优先队列的实现

优先队列的应用非常广泛，如操作系统的进程调度，或者简单当个堆用于堆排序、多路归并排序，在推荐系统中可作为带权重的随机选择器。

优先队列的实现是基于堆，它的插入和删除操作的时间复杂度为O(logN)。插入在堆尾插入，需要从下到上调整维持堆序；删除时需要拿堆尾元素填充到堆头，然后从上到下调整保持堆序。堆头可以从0开始，也可以从1开始，区别在于计算左右子节点的位置的时候是否要多加1。如果从0开始，父节点索引为n，则左子节点索引为2n+1，右子节点索引为2n+2；如果从1开始，父节点索引为n，则左子节点索引为2n，右子节点索引为2n+1。下面的实现是堆的索引从0开始。我们依旧实现常规队列里面的IQueue接口。默认使用小堆，即权重越低优先级越高。

```java
import java.util.Comparator;

public class MyPriorityQueue<T> implements IQueue<T> {
    private Comparator<? super T> comparator;
    private int capacity;
    private int tail;
    private T[] array;
    public MyPriorityQueue(int capacity) {
        this(capacity, null);
    }

    public MyPriorityQueue(int capacity, Comparator<? super T> comparator) {
        if (capacity < 1 || capacity > Integer.MAX_VALUE >> 2) {
            throw new IllegalArgumentException();
        }
        this.capacity = capacity;
        this.array = (T[]) new Object[capacity];
        this.comparator = comparator;
    }

    @Override
    public boolean enqueue(T item) {
        if (isFull()) {
            return false;
        }
        //如果没有比较器，且入队列元素不可比较
        if (comparator == null && !(item instanceof Comparable)) {
            throw new IllegalArgumentException();
        }
        array[tail] = item;
        tail ++;
        if (tail > 1) { //多于一个元素才调整
            siftUp(tail-1);
        }
        return true;
    }

    @Override
    public boolean isFull() {
        return tail == capacity;
    }

    @Override
    public T dequeue() {
        if (isEmpty()) {
            return null;
        }
        T item = array[0];
        tail --;
        array[0] = array[tail];
        array[tail] = null; //help gc
        if (tail > 1) { //多于一个元素才调整
            siftDown(0);
        }
        return item;
    }

    @Override
    public boolean isEmpty() {
        return tail == 0;
    }

    //自底向上调整堆,保持堆序，父节点小于子节点
    private void siftUp(int k) {
        int p = parent(k);
        if (comparator == null) {
            while(p >= 0) {
                Comparable<? super T> kItem = (Comparable<? super T>)array[k];
                T pItem = array[p];
                if (kItem.compareTo(pItem) < 0) {
                    swap(k, p);
                } else {
                    break;
                }
                k = p;
                p = parent(k);
            }
        } else {
            while (p >= 0) {
                if (comparator.compare(array[k], array[p]) < 0) {
                    swap(k, p);
                } else {
                    break;
                }
                k = p;
                p = parent(k);
            }
        }
    }

    //自顶向下调整，保证父节点小于左右子节点
    private void siftDown(int k) {
        int left = leftChild(k);
        if (comparator == null) {
            while (left < tail) {
                int right = rightChild(k);
                T min = array[left];
                int minIndex = left;
                if (right < tail) {
                    Comparable<? super  T> rItem = (Comparable<? super  T>)array[right];
                    if (rItem.compareTo(min) < 0) {
                        min = array[right];
                        minIndex = right;
                    }
                }
                //左右子节点的最小值小于父节点
                if (((Comparable<? super T>)min).compareTo(array[k]) < 0) {
                    swap(minIndex, k);
                    k = minIndex;
                    left = leftChild(k);
                } else {
                    break;
                }
            }
        } else {
            while (left < tail) {
                int right = rightChild(k);
                T min = array[left];
                int minIndex = left;
                if (right < tail && comparator.compare(array[right], min) < 0) {
                    min = array[right];
                    minIndex = right;
                }
                //左右子节点的最小值小于父节点
                if (comparator.compare(min, array[k]) < 0) {
                    swap(minIndex, k);
                    k = minIndex;
                    left = leftChild(k);
                } else {
                    break;
                }
            }
        }
    }

    //求指定索引的父节点位置
    private int parent(int k) {
        return (k-1)/2;
    }

    //求指定索引的左节点位置
    private int leftChild(int k) {
        return (2*k+1);
    }

    //求指定索引的右节点位置
    private int rightChild(int k) {
        return (2*k+2);
    }

    //交互数组里两元素
    private void swap(int i, int j) {
        T tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
```



